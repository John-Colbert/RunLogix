using Format, Units, IO, System;

//======================================================================================

readonly TimeBasedWorkoutsClass TimeBasedWorkouts = new;
readonly RawWorkoutsClass       RawWorkouts       = new;
readonly UnitSystems            UnitSystem        = Configuration.UnitSystem;
readonly FileEntryClass[]       Files             = EnumerateFiles(DataPath);

typedef DoubleList ListClass<double>;

MarginLayout = new ExtentClass(new ThicknessClass(1 inch, 0.5 inches, 1 inch, 1 inch));

//======================================================================================

namespace Measures {
  const double MetersPerKilometer        = (1 kilometer) intu meters;
  const double KilometersPerMeter        = (1 meter) intu kilometers;
  const double MetersPerMile             = (1 mile) intu meters;
  const double MilesPerMeter             = (1 meter) intu miles;
  const string Kilometer                 = "Kilometer";
  const string Mile                      = "Mile";
  const string Kilometers                = "Kilometers";
  const string Miles                     = "Miles";

  const double MetersToFeetFactor        = 3.280839895;
  const double MinPerMiToMinPerKMFactor  = 0.6213692038495188;
  const double MinPerKmToMinPerMiFactor  = 1.6093491499172796;

  readonly string DistanceAbbr           = UnitSystem == UnitSystems.Metric ? " km" : " mi";
  readonly string MinutesPerAbbr         = UnitSystem == UnitSystems.Metric ? " min/km" : " min/mi";
  readonly double PerMeterFactor         = UnitSystem == UnitSystems.Metric ? Measures.KilometersPerMeter : Measures.MilesPerMeter;
  readonly double MetersPerFactor        = UnitSystem == UnitSystem.Metric  ? Measures.MetersPerKilometer : Measures.MetersPerMile;
  readonly DistanceTypes DistanceType    = UnitSystem == UnitSystem.Metric ? DistanceTypes.Kilometer : DistanceTypes.Mile;
  readonly string DistanceUnitSingle     = UnitSystem == UnitSystem.Metric ? Kilometer : Mile;
  readonly string DistanceUnitPlural     = UnitSystem == UnitSystem.Metric ? Kilometers : Miles;
}
//======================================================================================

namespace Convert {
  double MinutesToDouble(string minutes) {
    var parts = minutes.Split(":");
    if (parts.Length != 2)
      Assert(false, "Time must be entered as minutes and seconds, with two digits for each (i.e. \"12:01\" or \"01:15\")");

    int paceMinutes = parts[0] as int;
    int paceSeconds = parts[1] as int;

    return paceMinutes + paceSeconds * 0.016666666667;
  }

  double ConvertPace(double pace, PaceTypes fromType) {
    if (fromType == PaceTypes.MinPerMi)
      return pace * Measures.MinPerMiToMinPerKMFactor;
    else
      return pace * Measures.MinPerKmToMinPerMiFactor;
  }
}
//======================================================================================

namespace Utilities {
  ElevationClass GetElevationMetrics(DoubleList elevationReadings) {
    if (elevationReadings.Length <= 0)
      return new ElevationClass(0, 0);

    double start = elevationReadings[0];
    double distanceUp = 0;
    double distanceDown = 0;

    double lastVal = start;

    foreach (var ele in elevationReadings) {
      if (ele > lastVal)
        distanceUp += ele - lastVal;
      else if (ele < lastVal)
        distanceDown += lastVal - ele;

      lastVal = ele;
    }

    if (UnitSystem == UnitSystems.Imperial) {
      distanceUp = distanceUp * Measures.MetersToFeetFactor;
      distanceDown = distanceDown * Measures.MetersToFeetFactor;
    }

    return new ElevationClass(distanceUp, distanceDown);
  }

  GetElevationShape(DoubleList elevationReadings) = Canvas {
    if (elevationReadings.Length <= 0)
      return;

    double width                 = (0.75 inches) intu pixels;
    int readingsPerWidthPixel = elevationReadings.Length > width ? (elevationReadings.Length / width) as int : elevationReadings.Length;

    double max = 0;
    double min = double.MaxValue;

    for (int i = 0; i < elevationReadings.Length; i += readingsPerWidthPixel) {
      var e = elevationReadings[i];
      max = Math.Max(e, max);
      min = Math.Min(e, min);
    }

    double diff  = max - min;
    double height = diff * 0.8;
    double delta = 3;
    double h = height - delta;

    Shape(Colors.DarkGray, null, null, width, height) {
      ClosedPath(0, height) {
        for (int i = 0; i < elevationReadings.Length; i += readingsPerWidthPixel) {
          var e = elevationReadings[i];

          LineTo((i / elevationReadings.Length) * width, h - (e - min) / diff * h);
        }
        LineTo(width, height);
      };
    };
  };
}
//======================================================================================

enum PaceTypes {
  MinPerKm ("min/km"),
  MinPerMi ("min/mi")
}

enum DistanceTypes {
  Meters,
  Kilometer,
  Mile
}
//======================================================================================